import argparse
import re
import subprocess
import sys
from collections import namedtuple
from enum import Enum
from inspect import cleandoc
from pathlib import Path
from shutil import which

from scripts.git import tags

Version = namedtuple("Version", ["major", "minor", "patch"])


class VersionCheckStatus(Enum):
    SUCCESS = 0
    FAILURE = 1


# fmt: off
_VERSION_MODULE_TEMPLATE = cleandoc('''
# ATTENTION: 
# This file is generated, do not edit it manually!
# If you need to change the version, do so in the project.toml, e.g. by using `poetry version X.Y.Z`.

MAJOR = {major}
MINOR = {minor}
PATCH = {patch}

VERSION = f"{{MAJOR}}.{{MINOR}}.{{PATCH}}"
''') + "\n"


# fmt: on


def version_from_string(s):
    """Converts a version string of the following format major.minor.patch to a version object"""
    major, minor, patch = (int(number, base=0) for number in s.split("."))
    return Version(major, minor, patch)


class CommitHookError(Exception):
    """Indicates that this commit hook encountered an error"""


def version_from_python_module(path):
    """Retrieve version information from the `version` module"""
    if not path.exists():
        return None
    with open(path) as file:
        _locals, _globals = {}, {}
        exec(file.read(), _locals, _globals)

        try:
            version = _globals["VERSION"]
        except KeyError as ex:
            raise CommitHookError("Couldn't find version within module") from ex

        return version_from_string(version)


def version_from_poetry():
    poetry = which("poetry")
    if not poetry:
        raise CommitHookError("Couldn't find poetry executable")

    result = subprocess.run([poetry, "version"], capture_output=True)
    version = result.stdout.decode().split()[1]
    return version_from_string(version)


def version_from_change_log():
    # Path overloads __truediv__
    path_to_changelog = Path(__file__).parent / ".." / "doc" / "changes" / "changelog.md"
    with open(path_to_changelog) as changelog:
        changelog_str = changelog.read()
        # Search for the FIRST pattern like: "* [0.5.0](changes_0.5.0.md)" in the changelog file.
        # Note that we encapsulate the [(0.5.0)] with parenthesis, which tells re to return the matching string as group
        version_match = re.search(r"\* \[([0-9]+.[0-9]+.[0-9]+)]\(\S+\)", changelog_str)
        return version_from_string(version_match.groups()[0])


def version_from_tags():
    tag_list = tags()
    if len(tag_list) == 0:
        return None
    else:
        return version_from_string(tag_list[-1])


def write_version_module(version, path, exists_ok=True):
    version_file = Path(path)
    if version_file.exists() and not exists_ok:
        raise CommitHookError(f"Version file [{version_file}] already exists.")
    version_file.unlink(missing_ok=True)
    with open(version_file, "w") as f:
        f.write(
            _VERSION_MODULE_TEMPLATE.format(
                major=version.major, minor=version.minor, patch=version.patch
            )
        )


def _create_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument("version_module", help="Path to version module")
    parser.add_argument("files", nargs="*")
    parser.add_argument(
        "-d",
        "--debug",
        action="store_true",
        default=False,
        help="enabled debug mode for execution.",
    )
    parser.add_argument(
        "-f",
        "--fix",
        action="store_true",
        default=False,
        help="fix instead of check.",
    )
    return parser


def check_or_fix_version(fix: bool, version_module: Path):
    module_version = version_from_python_module(version_module)
    poetry_version = version_from_poetry()
    tag_version = version_from_tags()
    changelog_version = version_from_change_log()
    result = VersionCheckStatus.SUCCESS

    if fix:
        write_version_module(poetry_version, version_module)
        module_version = version_from_python_module(version_module)

    if not module_version == poetry_version:
        print(
            f"Version in pyproject.toml {poetry_version} and {version_module} {module_version} do not match!"
        )
        if fix:
            print(
                f"Updating version in file ({version_module}) from {module_version} to {poetry_version}"
            )
        result = VersionCheckStatus.FAILURE

    if not poetry_version == changelog_version:
        print(
            f"Version in pyproject.toml {poetry_version} and changelog {changelog_version} do not match!"
        )
        result = VersionCheckStatus.FAILURE

    if tag_version is None and poetry_version != Version(0, 1, 0):
        print("You don't have yet a release. Your Poetry version needs to be 0.1.0!")

    # We expect that the current version in pyproject.toml is always greater than the latest tag.
    # Thus we avoid creating a release without having the version number updated.
    if poetry_version == tag_version:
        print("Version in pyproject.toml {poetry_version} is equal to your last tag. "
              "You need to update your poetry version!")
        result = VersionCheckStatus.FAILURE

    return result


def _main_debug(args):
    status = check_or_fix_version(args.fix, Path(args.version_module))
    return status.value


def _main(args):
    try:
        return _main_debug(args)
    except Exception as ex:
        print(f"Error while executing program, details: {ex}", file=sys.stderr)
        return VersionCheckStatus.FAILURE.value


def main(argv=None):
    parser = _create_parser()
    args = parser.parse_args()
    entry_point = _main if not args.debug else _main_debug
    return entry_point(args)


if __name__ == "__main__":
    sys.exit(main())
